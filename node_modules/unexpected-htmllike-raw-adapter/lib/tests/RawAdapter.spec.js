'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _unexpected = require('unexpected');

var _unexpected2 = _interopRequireDefault(_unexpected);

var _ = require('../');

var _2 = _interopRequireDefault(_);

var _DummyAdapter = require('./DummyAdapter');

var _DummyAdapter2 = _interopRequireDefault(_DummyAdapter);

var expect = _unexpected2['default'].clone();

describe('RawAdapter', function () {

    var adapter = undefined;

    beforeEach(function () {
        adapter = new _2['default']();
    });

    describe('getName()', function () {

        it('gets the name of a native component', function () {

            var tree = { type: 'span', attributes: {} };
            expect(adapter.getName(tree), 'to equal', 'span');
        });
    });

    describe('getAttributes()', function () {

        it('gets standard string attributes', function () {

            var tree = { type: 'span', props: { test1: 'foo', test2: 'bar' } };
            expect(adapter.getAttributes(tree), 'to equal', {
                test1: 'foo',
                test2: 'bar'
            });
        });

        it('gets numeric attributes', function () {

            var tree = { type: 'span', props: { test1: 42, test2: 305.12 } };
            expect(adapter.getAttributes(tree), 'to equal', {
                test1: 42,
                test2: 305.12
            });
        });

        it('gets object attributes', function () {

            var tree = { type: 'span', props: { test1: { test: 'foo', num: 42 } } };
            expect(adapter.getAttributes(tree), 'to equal', {
                test1: { test: 'foo', num: 42 }
            });
        });
    });

    describe('setOptions()', function () {

        it('sets an option', function () {

            adapter.setOptions({ someOption: true });
            expect(adapter.getOptions(), 'to satisfy', { someOption: true });
        });
    });

    describe('getChildren()', function () {

        it('gets an empty array when there are no children', function () {

            var tree = { type: 'span', props: {} };
            expect(adapter.getChildren(tree), 'to equal', []);
        });

        it('gets an array with one string child', function () {

            var tree = { type: 'span', props: {}, children: ['foo'] };
            expect(adapter.getChildren(tree), 'to equal', ['foo']);
        });

        it('gets an array with one numeric child', function () {

            var tree = { type: 'span', props: {}, children: [42] };
            expect(adapter.getChildren(tree), 'to equal', [42]);
        });

        it('gets an array with a component child', function () {

            var tree = {
                type: 'span',
                props: {},
                children: [{
                    type: 'div',
                    props: {},
                    children: ['some text']
                }]
            };
            expect(adapter.getChildren(tree), 'to equal', [{ type: 'div', props: {}, children: ['some text'] }]);
        });

        it('gets an array with several component children', function () {

            var tree = {
                type: 'span',
                props: {},
                children: [{
                    type: 'div',
                    props: {},
                    children: ['some text']
                }, {
                    type: 'div',
                    props: {},
                    children: ['foo']
                }, {
                    type: 'span',
                    props: {
                        attrib: 'hello world'
                    },
                    children: ['cheese']
                }]
            };

            expect(adapter.getChildren(tree), 'to equal', [{ type: 'div', props: {}, children: ['some text'] }, { type: 'div', props: {}, children: ['foo'] }, { type: 'span', props: { attrib: 'hello world' }, children: ['cheese'] }]);
        });

        it('does not concat text children by default', function () {

            var tree = {
                type: 'span',
                props: {},
                children: ['Hello ', 42, ' world']
            };

            expect(adapter.getChildren(tree), 'to equal', ['Hello ', 42, ' world']);
        });

        it('does concat text children when concatTextContent is true', function () {

            var tree = {
                type: 'span',
                props: {},
                children: ['Hello ', 42, ' world']
            };
            adapter.setOptions({ concatTextContent: true });

            expect(adapter.getChildren(tree), 'to equal', ['Hello 42 world']);
        });

        it('converts content to strings when `convertToString` option is true', function () {

            var tree = {
                type: 'span',
                props: {},
                children: ['Hello ', 42, ' world']
            };
            adapter.setOptions({ convertToString: true });

            expect(adapter.getChildren(tree), 'to equal', ['Hello ', '42', ' world']);
        });

        it('converts content with null when `convertToString` option is true', function () {

            var tree = {
                type: 'span',
                props: {},
                children: ['Hello ', null, ' world']
            };
            adapter.setOptions({ convertToString: true });

            expect(adapter.getChildren(tree), 'to equal', ['Hello ', ' world']);
        });

        it('converts only raw content to strings', function () {

            var tree = {
                type: 'div',
                props: {},
                children: [{
                    type: 'span',
                    props: {},
                    children: ['Hello world ', 21]
                }, {
                    type: 'span',
                    props: {},
                    children: [42]
                }]
            };
            adapter.setOptions({ convertToString: true });

            expect(adapter.getChildren(tree), 'to equal', [{ type: 'span', props: {}, children: ['Hello world ', 21] }, { type: 'span', props: {}, children: [42] }]);
        });

        it('converts multiple raw content to strings using `convertMultipleRawToStrings:true`', function () {

            var tree = { type: 'span', props: {}, children: ['Hello world ', 21] };
            adapter.setOptions({ convertMultipleRawToStrings: true });

            expect(adapter.getChildren(tree), 'to equal', ['Hello world ', '21']);
        });

        it('leaves single raw content alone with `convertMultipleRawToStrings:true`', function () {

            var tree = { type: 'span', props: {}, children: [21] };
            adapter.setOptions({ convertMultipleRawToStrings: true });

            expect(adapter.getChildren(tree), 'to equal', [21]);
        });

        it('leaves content when there is only one item, after ignoring `null`s', function () {

            var tree = { type: 'span', props: {}, children: [null, 21] };
            adapter.setOptions({ convertMultipleRawToStrings: true });

            expect(adapter.getChildren(tree), 'to equal', [21]);
        });

        it('does not ignore boolean elements', function () {
            // I'm not sure what is "right" in this case
            // If we've produced it, we should allow it here, otherwise the readers and writers mismatch
            // On the other hand, booleans are ignored by react, so what business does it have here?
            var tree = {
                type: 'span',
                props: {},
                children: [true]
            };
            expect(adapter.getChildren(tree), 'to equal', [true]);
        });
    });

    it('returns a className prop as a className', function () {

        var tree = {
            type: 'span',
            props: { className: 'abc' }
        };
        expect(adapter.getAttributes(tree), 'to equal', { className: 'abc' });
    });

    it('returns the correct classAttributeName', function () {

        expect(adapter.classAttributeName, 'to equal', 'className');
    });

    describe('serialize', function () {

        var dummyAdapter = undefined;
        beforeEach(function () {
            dummyAdapter = new _DummyAdapter2['default']();
        });

        it('converts a single node', function () {
            var original = { type: 'span', props: { className: 'foo' } };
            var dummyElement = dummyAdapter.makeDummy(original);
            expect(adapter.serialize(dummyAdapter, dummyElement), 'to satisfy', original);
        });

        it('converts a node with child nodes', function () {
            var original = {
                type: 'span',
                props: { className: 'foo' },
                children: [{ type: 'div', props: { id: 'bar' } }]
            };
            var dummyElement = dummyAdapter.makeDummy(original);
            expect(adapter.serialize(dummyAdapter, dummyElement), 'to satisfy', original);
        });

        it('converts a node with mixed content child nodes', function () {
            var original = {
                type: 'span',
                props: { className: 'foo' },
                children: [{ type: 'div', props: { id: 'bar' } }, 'hello', 42, { type: 'span', props: {}, children: ['baz'] }]
            };
            var dummyElement = dummyAdapter.makeDummy(original);
            expect(adapter.serialize(dummyAdapter, dummyElement), 'to satisfy', original);
        });
    });

    describe('isRawElement', function () {

        var dummyAdapter = undefined;
        beforeEach(function () {
            dummyAdapter = new _DummyAdapter2['default']();
        });

        it('returns true from something from a convertFromOther', function () {
            var original = { type: 'span', props: { className: 'foo' } };
            var dummyElement = dummyAdapter.makeDummy(original);
            var converted = adapter.serialize(dummyAdapter, dummyElement);
            expect(adapter.isRawElement(converted), 'to be true');
        });

        it('returns false on an object with type,props and children', function () {
            var original = { type: 'span', props: { className: 'foo' }, children: [] };
            expect(adapter.isRawElement(original), 'to be false');
        });

        it('returns true on a deserialized object with type,props and children', function () {
            var original = { type: 'span', props: { className: 'foo' }, children: [] };
            expect(adapter.isRawElement(adapter.deserialize(original)), 'to be true');
        });
    });

    describe('function prop deserialization', function () {

        it('deserializers a function to include the _isRawDeserializedFunction property', function () {

            var original = { type: 'span', props: { onClick: function doSomething() {} } };
            var deserialized = adapter.deserialize(original);
            expect(deserialized.props.onClick, 'to have properties', { _isRawDeserializedFunction: true });
        });
    });
});
//# sourceMappingURL=RawAdapter.spec.js.map