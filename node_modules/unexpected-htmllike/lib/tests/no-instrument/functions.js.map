{"version":3,"sources":["../../../src/tests/no-instrument/functions.js"],"names":[],"mappings":";;AACA,IAAI,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,cAAc,EAAE,cAAc,CAAC;;;;;;;AAOnE,IAAI,CAAC,wDAAwD,CAAC,CAAC;;AAE/D,IAAI,kIAGD,CAAC;;AAEJ,IAAI,uJAGD,CAAC;;AAEJ,IAAI,0EAED,CAAC;;AAEJ,IAAI,CAAC,0LAA0L,CAAC,CAAC;;AAEjM,MAAM,CAAC,OAAO,GAAG,EAAE,SAAS,EAAT,SAAS,EAAE,QAAQ,EAAR,QAAQ,EAAE,SAAS,EAAT,SAAS,EAAE,cAAc,EAAd,cAAc,EAAE,cAAc,EAAd,cAAc,EAAE,CAAC","file":"functions.js","sourcesContent":["\nvar shortFunc, longFunc, longFunc2, shortMultiLine, longSingleLine;\n\n// These functions are created with eval, in order to stop babel reformatting them.\n// This means they are left exactly as created when .toString() is called\n// This is important when testing the length of function bodies, and whether the \n// bodies contain newlines\n\neval('shortFunc = function shortFunc(a, b) { return a + b; }');\n\neval(`longFunc = function longFunc(a, b) {\n    console.log('This ia long func', a + b);\n    console.log('With multiple lines');\n}`);\n\neval(`longFunc2 = function longFunc2(a, b) {\n    console.log('This ia long func', a + b);\n    console.log('With multiple lines that are different');\n}`);\n\neval(`shortMultiLine = function shortMultiLine(a, b) {\n    return a + b;\n}`);\n\neval(\"longSingleLine = function longSingleLine(a, b) { console.log('this is a long function that is only on one line'); console.log('All javascript functions should be written like this'); }\");\n\nmodule.exports = { shortFunc, longFunc, longFunc2, shortMultiLine, longSingleLine };\n"]}